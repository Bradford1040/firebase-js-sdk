Project: /docs/reference/js/_project.yaml
Book: /docs/reference/_book.yaml
page_type: reference

{% comment %}
DO NOT EDIT THIS FILE!
This is generated by the JS SDK team, and any local changes will be
overwritten. Changes should be made in the source code at
https://github.com/firebase/firebase-js-sdk
{% endcomment %}

# Pipeline class
Base-class implementation

<b>Signature:</b>

```typescript
export declare class Pipeline<AppModelType = DocumentData> 
```

## Methods

|  Method | Modifiers | Description |
|  --- | --- | --- |
|  [addFields(fields)](./firestore_lite.pipeline.md#pipelineaddfields) |  | Adds new fields to outputs from previous stages.<!-- -->This stage allows you to compute values on-the-fly based on existing data from previous stages or constants. You can use this to create new fields or overwrite existing ones (if there is name overlaps).<!-- -->The added fields are defined using [Selectable](./firestore_.selectable.md#selectable_interface)<!-- -->s, which can be:<!-- -->- [Field](./firestore_.field.md#field_class)<!-- -->: References an existing document field. - : Performs a calculation using functions like <code>add</code>, <code>multiply</code> with assigned aliases using .<!-- -->Example:
```typescript
firestore.pipeline().collection("books")
  .addFields(
    Field.of("rating").as("bookRating"), // Rename 'rating' to 'bookRating'
    add(5, Field.of("quantity")).as("totalCost")  // Calculate 'totalCost'
  );

```
 |
|  [aggregate(accumulators)](./firestore_lite.pipeline.md#pipelineaggregate) |  | Performs aggregation operations on the documents from previous stages.<p>This stage allows you to calculate aggregate values over a set of documents. You define the aggregations to perform using [AccumulatorTarget](./firestore_.md#accumulatortarget) expressions which are typically results of calling  on [Accumulator](./firestore_.accumulator.md#accumulator_interface) instances.<p>Example:
```typescript
// Calculate the average rating and the total number of books
firestore.pipeline().collection("books")
    .aggregate(
        Field.of("rating").avg().as("averageRating"),
        countAll().as("totalBooks")
    );

```
 |
|  [aggregate(options)](./firestore_lite.pipeline.md#pipelineaggregate) |  | Performs optionally grouped aggregation operations on the documents from previous stages.<p>This stage allows you to calculate aggregate values over a set of documents, optionally grouped by one or more fields or functions. You can specify:<ul> <li>\*\*Grouping Fields or Functions:\*\* One or more fields or functions to group the documents by. For each distinct combination of values in these fields, a separate group is created. If no grouping fields are provided, a single group containing all documents is used. Not specifying groups is the same as putting the entire inputs into one group.</li> <li>\*\*Accumulators:\*\* One or more accumulation operations to perform within each group. These are defined using [AccumulatorTarget](./firestore_.md#accumulatortarget) expressions, which are typically created by calling  on [Accumulator](./firestore_.accumulator.md#accumulator_interface) instances. Each aggregation calculates a value (e.g., sum, average, count) based on the documents within its group.</li> </ul><p>Example:
```typescript
// Calculate the average rating for each genre.
firestore.pipeline().collection("books")
  .aggregate({
      accumulators: [avg(Field.of("rating")).as("avg_rating")]
      groups: ["genre"]
      });

```
 |
|  [distinct(groups)](./firestore_lite.pipeline.md#pipelinedistinct) |  | Returns a set of distinct  values from the inputs to this stage.<p>This stage run through the results from previous stages to include only results with unique combinations of  values ([Field](./firestore_.field.md#field_class)<!-- -->, , etc).<p>The parameters to this stage are defined using [Selectable](./firestore_.selectable.md#selectable_interface) expressions or s:<ul> <li>: Name of an existing field</li> <li>[Field](./firestore_.field.md#field_class)<!-- -->: References an existing document field.</li> <li>: Represents the result of a function with an assigned alias name using </li> </ul><p>Example:
```typescript
// Get a list of unique author names in uppercase and genre combinations.
firestore.pipeline().collection("books")
    .distinct(toUppercase(Field.of("author")).as("authorName"), Field.of("genre"), "publishedAt")
    .select("authorName");

```
 |
|  [execute()](./firestore_lite.pipeline.md#pipelineexecute) |  | Executes this pipeline and returns a Promise to represent the asynchronous operation.<p>The returned Promise can be used to track the progress of the pipeline execution and retrieve the results (or handle any errors) asynchronously.<p>The pipeline results are returned as a list of [PipelineResult](./firestore_.pipelineresult.md#pipelineresult_class) objects. Each [PipelineResult](./firestore_.pipelineresult.md#pipelineresult_class) typically represents a single key/value map that has passed through all the stages of the pipeline, however this might differ depending on the stages involved in the pipeline. For example:<ul> <li>If there are no stages or only transformation stages, each [PipelineResult](./firestore_.pipelineresult.md#pipelineresult_class) represents a single document.</li> <li>If there is an aggregation, only a single [PipelineResult](./firestore_.pipelineresult.md#pipelineresult_class) is returned, representing the aggregated results over the entire dataset .</li> <li>If there is an aggregation stage with grouping, each [PipelineResult](./firestore_.pipelineresult.md#pipelineresult_class) represents a distinct group and its associated aggregated values.</li> </ul><p>Example:
```typescript
const futureResults = await firestore.pipeline().collection("books")
    .where(gt(Field.of("rating"), 4.5))
    .select("title", "author", "rating")
    .execute();

```
 A Promise representing the asynchronous pipeline execution. |
|  [findNearest(options)](./firestore_lite.pipeline.md#pipelinefindnearest) |  |  |
|  [genericStage(name, params)](./firestore_lite.pipeline.md#pipelinegenericstage) |  | Adds a generic stage to the pipeline.<p>This method provides a flexible way to extend the pipeline's functionality by adding custom stages. Each generic stage is defined by a unique <code>name</code> and a set of <code>params</code> that control its behavior.<p>Example (Assuming there is no "where" stage available in SDK):
```typescript
// Assume we don't have a built-in "where" stage
firestore.pipeline().collection("books")
    .genericStage("where", [Field.of("published").lt(1900)]) // Custom "where" stage
    .select("title", "author");

```
 |
|  [limit(limit)](./firestore_lite.pipeline.md#pipelinelimit) |  | Limits the maximum number of documents returned by previous stages to <code>limit</code>.<p>This stage is particularly useful when you want to retrieve a controlled subset of data from a potentially large result set. It's often used for:<ul> <li>\*\*Pagination:\*\* In combination with  to retrieve specific pages of results.</li> <li>\*\*Limiting Data Retrieval:\*\* To prevent excessive data transfer and improve performance, especially when dealing with large collections.</li> </ul><p>Example:
```typescript
// Limit the results to the top 10 highest-rated books
firestore.pipeline().collection("books")
    .sort(Field.of("rating").descending())
    .limit(10);

```
 |
|  [offset(offset)](./firestore_lite.pipeline.md#pipelineoffset) |  | Skips the first <code>offset</code> number of documents from the results of previous stages.<p>This stage is useful for implementing pagination in your pipelines, allowing you to retrieve results in chunks. It is typically used in conjunction with  to control the size of each page.<p>Example:
```typescript
// Retrieve the second page of 20 results
firestore.pipeline().collection("books")
    .sort(Field.of("published").descending())
    .offset(20)  // Skip the first 20 results
    .limit(20);   // Take the next 20 results

```
 |
|  [select(selections)](./firestore_lite.pipeline.md#pipelineselect) |  | Selects or creates a set of fields from the outputs of previous stages.<p>The selected fields are defined using [Selectable](./firestore_.selectable.md#selectable_interface) expressions, which can be:<ul> <li>: Name of an existing field</li> <li>[Field](./firestore_.field.md#field_class)<!-- -->: References an existing field.</li> <li>: Represents the result of a function with an assigned alias name using </li> </ul><p>If no selections are provided, the output of this stage is empty. Use  instead if only additions are desired.<p>Example:
```typescript
firestore.pipeline().collection("books")
  .select(
    "firstName",
    Field.of("lastName"),
    Field.of("address").toUppercase().as("upperAddress"),
  );

```
 |
|  [sort(orderings)](./firestore_lite.pipeline.md#pipelinesort) |  | Sorts the documents from previous stages based on one or more [Ordering](./firestore_.ordering.md#ordering_class) criteria.<p>This stage allows you to order the results of your pipeline. You can specify multiple [Ordering](./firestore_.ordering.md#ordering_class) instances to sort by multiple fields in ascending or descending order. If documents have the same value for a field used for sorting, the next specified ordering will be used. If all orderings result in equal comparison, the documents are considered equal and the order is unspecified.<p>Example:
```typescript
// Sort books by rating in descending order, and then by title in ascending order for books
// with the same rating
firestore.pipeline().collection("books")
    .sort(
        Ordering.of(Field.of("rating")).descending(),
        Ordering.of(Field.of("title"))  // Ascending order is the default
    );

```
 |
|  [sort(options)](./firestore_lite.pipeline.md#pipelinesort) |  |  |
|  [where(condition)](./firestore_lite.pipeline.md#pipelinewhere) |  | Filters the documents from previous stages to only include those matching the specified [FilterCondition](./firestore_.filtercondition.md#filtercondition_interface)<!-- -->.<p>This stage allows you to apply conditions to the data, similar to a "WHERE" clause in SQL. You can filter documents based on their field values, using implementations of [FilterCondition](./firestore_.filtercondition.md#filtercondition_interface)<!-- -->, typically including but not limited to:<ul> <li>field comparators: ,  (less than),  (greater than), etc.</li> <li>logical operators: , , , etc.</li> <li>advanced functions: , , etc.</li> </ul><p>Example:
```typescript
firestore.pipeline().collection("books")
  .where(
    and(
        gt(Field.of("rating"), 4.0),   // Filter for ratings greater than 4.0
        Field.of("genre").eq("Science Fiction") // Equivalent to gt("genre", "Science Fiction")
    )
  );

```
 |

## Pipeline.addFields()

Adds new fields to outputs from previous stages.

This stage allows you to compute values on-the-fly based on existing data from previous stages or constants. You can use this to create new fields or overwrite existing ones (if there is name overlaps).

The added fields are defined using [Selectable](./firestore_.selectable.md#selectable_interface)<!-- -->s, which can be:

- [Field](./firestore_.field.md#field_class)<!-- -->: References an existing document field. - : Performs a calculation using functions like `add`<!-- -->, `multiply` with assigned aliases using .

Example:

```typescript
firestore.pipeline().collection("books")
  .addFields(
    Field.of("rating").as("bookRating"), // Rename 'rating' to 'bookRating'
    add(5, Field.of("quantity")).as("totalCost")  // Calculate 'totalCost'
  );

```

<b>Signature:</b>

```typescript
addFields(...fields: Selectable[]): Pipeline<AppModelType>;
```

#### Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  fields | [Selectable](./firestore_lite.selectable.md#selectable_interface)<!-- -->\[\] | The fields to add to the documents, specified as [Selectable](./firestore_.selectable.md#selectable_interface)<!-- -->s.  A new Pipeline object with this stage appended to the stage list. |

<b>Returns:</b>

[Pipeline](./firestore_lite.pipeline.md#pipeline_class)<!-- -->&lt;AppModelType&gt;

## Pipeline.aggregate()

Performs aggregation operations on the documents from previous stages.

<p>This stage allows you to calculate aggregate values over a set of documents. You define the aggregations to perform using [AccumulatorTarget](./firestore_.md#accumulatortarget) expressions which are typically results of calling  on [Accumulator](./firestore_.accumulator.md#accumulator_interface) instances.

<p>Example:

```typescript
// Calculate the average rating and the total number of books
firestore.pipeline().collection("books")
    .aggregate(
        Field.of("rating").avg().as("averageRating"),
        countAll().as("totalBooks")
    );

```

<b>Signature:</b>

```typescript
aggregate(...accumulators: AccumulatorTarget[]): Pipeline<AppModelType>;
```

#### Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  accumulators | [AccumulatorTarget](./firestore_lite.md#accumulatortarget)<!-- -->\[\] | The [AccumulatorTarget](./firestore_.md#accumulatortarget) expressions, each wrapping an [Accumulator](./firestore_.accumulator.md#accumulator_interface) and provide a name for the accumulated results.  A new Pipeline object with this stage appended to the stage list. |

<b>Returns:</b>

[Pipeline](./firestore_lite.pipeline.md#pipeline_class)<!-- -->&lt;AppModelType&gt;

## Pipeline.aggregate()

Performs optionally grouped aggregation operations on the documents from previous stages.

<p>This stage allows you to calculate aggregate values over a set of documents, optionally grouped by one or more fields or functions. You can specify:

<ul> <li>\*\*Grouping Fields or Functions:\*\* One or more fields or functions to group the documents by. For each distinct combination of values in these fields, a separate group is created. If no grouping fields are provided, a single group containing all documents is used. Not specifying groups is the same as putting the entire inputs into one group.</li> <li>\*\*Accumulators:\*\* One or more accumulation operations to perform within each group. These are defined using [AccumulatorTarget](./firestore_.md#accumulatortarget) expressions, which are typically created by calling  on [Accumulator](./firestore_.accumulator.md#accumulator_interface) instances. Each aggregation calculates a value (e.g., sum, average, count) based on the documents within its group.</li> </ul>

<p>Example:

```typescript
// Calculate the average rating for each genre.
firestore.pipeline().collection("books")
  .aggregate({
      accumulators: [avg(Field.of("rating")).as("avg_rating")]
      groups: ["genre"]
      });

```

<b>Signature:</b>

```typescript
aggregate(options: {
        accumulators: AccumulatorTarget[];
        groups?: Array<string | Selectable>;
    }): Pipeline<AppModelType>;
```

#### Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  options | { accumulators: [AccumulatorTarget](./firestore_lite.md#accumulatortarget)<!-- -->\[\]; groups?: Array&lt;string \| [Selectable](./firestore_lite.selectable.md#selectable_interface)<!-- -->&gt;; } |  |

<b>Returns:</b>

[Pipeline](./firestore_lite.pipeline.md#pipeline_class)<!-- -->&lt;AppModelType&gt;

## Pipeline.distinct()

Returns a set of distinct  values from the inputs to this stage.

<p>This stage run through the results from previous stages to include only results with unique combinations of  values ([Field](./firestore_.field.md#field_class)<!-- -->, , etc).

<p>The parameters to this stage are defined using [Selectable](./firestore_.selectable.md#selectable_interface) expressions or s:

<ul> <li>: Name of an existing field</li> <li>[Field](./firestore_.field.md#field_class)<!-- -->: References an existing document field.</li> <li>: Represents the result of a function with an assigned alias name using </li> </ul>

<p>Example:

```typescript
// Get a list of unique author names in uppercase and genre combinations.
firestore.pipeline().collection("books")
    .distinct(toUppercase(Field.of("author")).as("authorName"), Field.of("genre"), "publishedAt")
    .select("authorName");

```

<b>Signature:</b>

```typescript
distinct(...groups: Array<string | Selectable>): Pipeline<AppModelType>;
```

#### Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  groups | Array&lt;string \| [Selectable](./firestore_lite.selectable.md#selectable_interface)<!-- -->&gt; |  |

<b>Returns:</b>

[Pipeline](./firestore_lite.pipeline.md#pipeline_class)<!-- -->&lt;AppModelType&gt;

## Pipeline.execute()

Executes this pipeline and returns a Promise to represent the asynchronous operation.

<p>The returned Promise can be used to track the progress of the pipeline execution and retrieve the results (or handle any errors) asynchronously.

<p>The pipeline results are returned as a list of [PipelineResult](./firestore_.pipelineresult.md#pipelineresult_class) objects. Each [PipelineResult](./firestore_.pipelineresult.md#pipelineresult_class) typically represents a single key/value map that has passed through all the stages of the pipeline, however this might differ depending on the stages involved in the pipeline. For example:

<ul> <li>If there are no stages or only transformation stages, each [PipelineResult](./firestore_.pipelineresult.md#pipelineresult_class) represents a single document.</li> <li>If there is an aggregation, only a single [PipelineResult](./firestore_.pipelineresult.md#pipelineresult_class) is returned, representing the aggregated results over the entire dataset .</li> <li>If there is an aggregation stage with grouping, each [PipelineResult](./firestore_.pipelineresult.md#pipelineresult_class) represents a distinct group and its associated aggregated values.</li> </ul>

<p>Example:

```typescript
const futureResults = await firestore.pipeline().collection("books")
    .where(gt(Field.of("rating"), 4.5))
    .select("title", "author", "rating")
    .execute();

```
 A Promise representing the asynchronous pipeline execution.

<b>Signature:</b>

```typescript
execute(): Promise<Array<PipelineResult<AppModelType>>>;
```
<b>Returns:</b>

Promise&lt;Array&lt;[PipelineResult](./firestore_lite.pipelineresult.md#pipelineresult_class)<!-- -->&lt;AppModelType&gt;&gt;&gt;

## Pipeline.findNearest()

<b>Signature:</b>

```typescript
findNearest(options: FindNearestOptions): Pipeline<AppModelType>;
```

#### Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  options | [FindNearestOptions](./firestore_lite.findnearestoptions.md#findnearestoptions_interface) |  |

<b>Returns:</b>

[Pipeline](./firestore_lite.pipeline.md#pipeline_class)<!-- -->&lt;AppModelType&gt;

## Pipeline.genericStage()

Adds a generic stage to the pipeline.

<p>This method provides a flexible way to extend the pipeline's functionality by adding custom stages. Each generic stage is defined by a unique `name` and a set of `params` that control its behavior.

<p>Example (Assuming there is no "where" stage available in SDK):

```typescript
// Assume we don't have a built-in "where" stage
firestore.pipeline().collection("books")
    .genericStage("where", [Field.of("published").lt(1900)]) // Custom "where" stage
    .select("title", "author");

```

<b>Signature:</b>

```typescript
genericStage(name: string, params: any[]): Pipeline<AppModelType>;
```

#### Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  name | string | The unique name of the generic stage to add. |
|  params | any\[\] | A list of parameters to configure the generic stage's behavior.  A new  object with this stage appended to the stage list. |

<b>Returns:</b>

[Pipeline](./firestore_lite.pipeline.md#pipeline_class)<!-- -->&lt;AppModelType&gt;

## Pipeline.limit()

Limits the maximum number of documents returned by previous stages to `limit`<!-- -->.

<p>This stage is particularly useful when you want to retrieve a controlled subset of data from a potentially large result set. It's often used for:

<ul> <li>\*\*Pagination:\*\* In combination with  to retrieve specific pages of results.</li> <li>\*\*Limiting Data Retrieval:\*\* To prevent excessive data transfer and improve performance, especially when dealing with large collections.</li> </ul>

<p>Example:

```typescript
// Limit the results to the top 10 highest-rated books
firestore.pipeline().collection("books")
    .sort(Field.of("rating").descending())
    .limit(10);

```

<b>Signature:</b>

```typescript
limit(limit: number): Pipeline<AppModelType>;
```

#### Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  limit | number | The maximum number of documents to return.  A new Pipeline object with this stage appended to the stage list. |

<b>Returns:</b>

[Pipeline](./firestore_lite.pipeline.md#pipeline_class)<!-- -->&lt;AppModelType&gt;

## Pipeline.offset()

Skips the first `offset` number of documents from the results of previous stages.

<p>This stage is useful for implementing pagination in your pipelines, allowing you to retrieve results in chunks. It is typically used in conjunction with  to control the size of each page.

<p>Example:

```typescript
// Retrieve the second page of 20 results
firestore.pipeline().collection("books")
    .sort(Field.of("published").descending())
    .offset(20)  // Skip the first 20 results
    .limit(20);   // Take the next 20 results

```

<b>Signature:</b>

```typescript
offset(offset: number): Pipeline<AppModelType>;
```

#### Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  offset | number | The number of documents to skip.  A new Pipeline object with this stage appended to the stage list. |

<b>Returns:</b>

[Pipeline](./firestore_lite.pipeline.md#pipeline_class)<!-- -->&lt;AppModelType&gt;

## Pipeline.select()

Selects or creates a set of fields from the outputs of previous stages.

<p>The selected fields are defined using [Selectable](./firestore_.selectable.md#selectable_interface) expressions, which can be:

<ul> <li>: Name of an existing field</li> <li>[Field](./firestore_.field.md#field_class)<!-- -->: References an existing field.</li> <li>: Represents the result of a function with an assigned alias name using </li> </ul>

<p>If no selections are provided, the output of this stage is empty. Use  instead if only additions are desired.

<p>Example:

```typescript
firestore.pipeline().collection("books")
  .select(
    "firstName",
    Field.of("lastName"),
    Field.of("address").toUppercase().as("upperAddress"),
  );

```

<b>Signature:</b>

```typescript
select(...selections: Array<Selectable | string>): Pipeline<AppModelType>;
```

#### Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  selections | Array&lt;[Selectable](./firestore_lite.selectable.md#selectable_interface) \| string&gt; | The fields to include in the output documents, specified as [Selectable](./firestore_.selectable.md#selectable_interface) expressions or  values representing field names.  A new Pipeline object with this stage appended to the stage list. |

<b>Returns:</b>

[Pipeline](./firestore_lite.pipeline.md#pipeline_class)<!-- -->&lt;AppModelType&gt;

## Pipeline.sort()

Sorts the documents from previous stages based on one or more [Ordering](./firestore_.ordering.md#ordering_class) criteria.

<p>This stage allows you to order the results of your pipeline. You can specify multiple [Ordering](./firestore_.ordering.md#ordering_class) instances to sort by multiple fields in ascending or descending order. If documents have the same value for a field used for sorting, the next specified ordering will be used. If all orderings result in equal comparison, the documents are considered equal and the order is unspecified.

<p>Example:

```typescript
// Sort books by rating in descending order, and then by title in ascending order for books
// with the same rating
firestore.pipeline().collection("books")
    .sort(
        Ordering.of(Field.of("rating")).descending(),
        Ordering.of(Field.of("title"))  // Ascending order is the default
    );

```

<b>Signature:</b>

```typescript
sort(...orderings: Ordering[]): Pipeline<AppModelType>;
```

#### Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  orderings | [Ordering](./firestore_lite.ordering.md#ordering_class)<!-- -->\[\] |  |

<b>Returns:</b>

[Pipeline](./firestore_lite.pipeline.md#pipeline_class)<!-- -->&lt;AppModelType&gt;

## Pipeline.sort()

<b>Signature:</b>

```typescript
sort(options: {
        orderings: Ordering[];
    }): Pipeline<AppModelType>;
```

#### Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  options | { orderings: [Ordering](./firestore_lite.ordering.md#ordering_class)<!-- -->\[\]; } |  |

<b>Returns:</b>

[Pipeline](./firestore_lite.pipeline.md#pipeline_class)<!-- -->&lt;AppModelType&gt;

## Pipeline.where()

Filters the documents from previous stages to only include those matching the specified [FilterCondition](./firestore_.filtercondition.md#filtercondition_interface)<!-- -->.

<p>This stage allows you to apply conditions to the data, similar to a "WHERE" clause in SQL. You can filter documents based on their field values, using implementations of [FilterCondition](./firestore_.filtercondition.md#filtercondition_interface)<!-- -->, typically including but not limited to:

<ul> <li>field comparators: ,  (less than),  (greater than), etc.</li> <li>logical operators: , , , etc.</li> <li>advanced functions: , , etc.</li> </ul>

<p>Example:

```typescript
firestore.pipeline().collection("books")
  .where(
    and(
        gt(Field.of("rating"), 4.0),   // Filter for ratings greater than 4.0
        Field.of("genre").eq("Science Fiction") // Equivalent to gt("genre", "Science Fiction")
    )
  );

```

<b>Signature:</b>

```typescript
where(condition: FilterCondition & Constant): Pipeline<AppModelType>;
```

#### Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  condition | [FilterCondition](./firestore_lite.filtercondition.md#filtercondition_interface) &amp; [Constant](./firestore_lite.constant.md#constant_class) | The [FilterCondition](./firestore_.filtercondition.md#filtercondition_interface) to apply.  A new Pipeline object with this stage appended to the stage list. |

<b>Returns:</b>

[Pipeline](./firestore_lite.pipeline.md#pipeline_class)<!-- -->&lt;AppModelType&gt;

