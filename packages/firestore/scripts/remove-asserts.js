"use strict";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var __spreadArray=this&&this.__spreadArray||function(to,from,pack){if(pack||arguments.length===2)for(var i=0,l=from.length,ar;i<l;i++){if(ar||!(i in from)){if(!ar)ar=Array.prototype.slice.call(from,0,i);ar[i]=from[i]}}return to.concat(ar||Array.prototype.slice.call(from))};exports.__esModule=true;exports.removeAsserts=void 0;var crypto_1=require("crypto");var fs_1=require("fs");var path_1=require("path");var ts=require("typescript");var ASSERT_LOCATION="packages/firestore/src/util/assert.ts";var ERROR_CODE_LOCATION="../dist/error_codes.json";function removeAsserts(program){var removeAsserts=new RemoveAsserts(program.getTypeChecker());return function(context){return function(file){return removeAsserts.visitNodeAndChildren(file,context)}}}exports.removeAsserts=removeAsserts;var RemoveAsserts=function(){function RemoveAsserts(typeChecker){this.typeChecker=typeChecker}RemoveAsserts.prototype.visitNodeAndChildren=function(node,context){var _this=this;return ts.visitEachChild(this.visitNode(node),(function(childNode){return _this.visitNodeAndChildren(childNode,context)}),context)};RemoveAsserts.prototype.visitNode=function(node){var updatedNode=null;if(ts.isCallExpression(node)){var signature=this.typeChecker.getResolvedSignature(node);if(signature&&signature.declaration&&signature.declaration.kind===ts.SyntaxKind.FunctionDeclaration){var declaration=signature.declaration;if(declaration&&declaration.getSourceFile().fileName.indexOf(ASSERT_LOCATION)>=0){var method=declaration.name.text;if(method==="debugAssert"){updatedNode=ts.createOmittedExpression()}else if(method==="hardAssert"||method==="fail"){var messageIndex=method==="hardAssert"?1:0;if(node.arguments.length>messageIndex&&node.arguments[messageIndex].kind===ts.SyntaxKind.StringLiteral){var stringLiteral=node.arguments[messageIndex];var errorMessage=RemoveAsserts.trimErrorMessage(stringLiteral.getFullText());var errorCode=RemoveAsserts.errorCode(errorMessage);try{RemoveAsserts.saveErrorCode(errorCode,errorMessage)}catch(e){console.log("Failed to save error code "+JSON.stringify(e))}var newArguments=__spreadArray([],node.arguments,true);newArguments[messageIndex]=ts.createLiteral(errorCode);updatedNode=ts.createCall(declaration.name,undefined,newArguments)}else{var newArguments=__spreadArray([],node.arguments,true);newArguments[messageIndex]=ts.createLiteral("Unexpected error");updatedNode=ts.createCall(declaration.name,undefined,newArguments)}}}}}if(updatedNode){ts.setSourceMapRange(updatedNode,ts.getSourceMapRange(node));return updatedNode}else{return node}};RemoveAsserts.trimErrorMessage=function(errorMessage){return errorMessage.substring(errorMessage.indexOf("'")+1,errorMessage.lastIndexOf("'"))};RemoveAsserts.errorCode=function(errorMessage){var hash=(0,crypto_1.createHash)("sha256");hash.update(errorMessage);var paramHash=hash.digest("hex").substring(0,7);return paramHash};RemoveAsserts.saveErrorCode=function(errorCode,errorMessage){var errorCodes=RemoveAsserts.getErrorCodes();errorCodes[errorCode]=errorMessage;RemoveAsserts.saveErrorCodes(errorCodes)};RemoveAsserts.getErrorCodes=function(){var path=(0,path_1.join)(module.path,ERROR_CODE_LOCATION);if(!(0,fs_1.existsSync)(path)){return{}}return JSON.parse((0,fs_1.readFileSync)(path,"utf-8"))};RemoveAsserts.saveErrorCodes=function(errorCodes){var path=(0,path_1.join)(module.path,ERROR_CODE_LOCATION);(0,fs_1.writeFileSync)(path,JSON.stringify(errorCodes,undefined,4),{encoding:"utf-8"})};return RemoveAsserts}();