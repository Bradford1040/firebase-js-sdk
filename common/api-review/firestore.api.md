## API Report File for "@firebase/firestore"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { EmulatorMockTokenOptions } from '@firebase/util';
import { FirebaseApp } from '@firebase/app';
import { FirebaseError } from '@firebase/util';
import { LogLevelString as LogLevel } from '@firebase/logger';

// @beta
export interface Accumulator extends Expr {
    // (undocumented)
    accumulator: true;
}

// @beta
export type AccumulatorTarget = ExprWithAlias<Accumulator>;

// @beta (undocumented)
export class Add extends FirestoreFunction {
    constructor(left: Expr, right: Expr);
    }

// @beta
export function add(left: Expr, right: Expr): Add;

// @beta
export function add(left: Expr, right: any): Add;

// @beta
export function add(left: string, right: Expr): Add;

// @beta
export function add(left: string, right: any): Add;

// @public
export function addDoc<AppModelType, DbModelType extends DocumentData>(reference: CollectionReference<AppModelType, DbModelType>, data: WithFieldValue<AppModelType>): Promise<DocumentReference<AppModelType, DbModelType>>;

// @beta (undocumented)
export class AddFields implements Stage {
    constructor(fields: Map<string, Expr>);
    // (undocumented)
    name: string;
}

// @public
export type AddPrefixToKeys<Prefix extends string, T extends Record<string, unknown>> = {
    [K in keyof T & string as `${Prefix}.${K}`]+?: string extends K ? any : T[K];
};

// @beta (undocumented)
export class Aggregate implements Stage {
    constructor(accumulators: Map<string, Accumulator>, groups: Map<string, Expr>);
    // (undocumented)
    name: string;
}

// @public
export class AggregateField<T> {
    readonly aggregateType: AggregateType;
    readonly type = "AggregateField";
}

// @public
export function aggregateFieldEqual(left: AggregateField<unknown>, right: AggregateField<unknown>): boolean;

// @public
export type AggregateFieldType = ReturnType<typeof sum> | ReturnType<typeof average> | ReturnType<typeof count>;

// @public
export class AggregateQuerySnapshot<AggregateSpecType extends AggregateSpec, AppModelType = DocumentData, DbModelType extends DocumentData = DocumentData> {
    data(): AggregateSpecData<AggregateSpecType>;
    readonly query: Query<AppModelType, DbModelType>;
    readonly type = "AggregateQuerySnapshot";
}

// @public
export function aggregateQuerySnapshotEqual<AggregateSpecType extends AggregateSpec, AppModelType, DbModelType extends DocumentData>(left: AggregateQuerySnapshot<AggregateSpecType, AppModelType, DbModelType>, right: AggregateQuerySnapshot<AggregateSpecType, AppModelType, DbModelType>): boolean;

// @public
export interface AggregateSpec {
    // (undocumented)
    [field: string]: AggregateFieldType;
}

// @public
export type AggregateSpecData<T extends AggregateSpec> = {
    [P in keyof T]: T[P] extends AggregateField<infer U> ? U : never;
};

// @public
export type AggregateType = 'count' | 'avg' | 'sum';

// @beta (undocumented)
export class And extends FirestoreFunction implements FilterCondition {
    constructor(conditions: (FilterCondition)[]);
    // (undocumented)
    filterable: true;
}

// @public
export function and(...queryConstraints: QueryFilterConstraint[]): QueryCompositeFilterConstraint;

// @beta
export function andFunction(left: FilterCondition, ...right: (FilterCondition)[]): And;

// @beta (undocumented)
export class ArrayConcat extends FirestoreFunction {
    constructor(array: Expr, elements: Expr[]);
    }

// @beta
export function arrayConcat(array: Expr, elements: Expr[]): ArrayConcat;

// @beta
export function arrayConcat(array: Expr, elements: any[]): ArrayConcat;

// @beta
export function arrayConcat(array: string, elements: Expr[]): ArrayConcat;

// @beta
export function arrayConcat(array: string, elements: any[]): ArrayConcat;

// @beta (undocumented)
export class ArrayContains extends FirestoreFunction implements FilterCondition {
    constructor(array: Expr, element: Expr);
    // (undocumented)
    filterable: true;
}

// @beta
export function arrayContains(array: Expr, element: Expr): ArrayContains;

// @beta
export function arrayContains(array: Expr, element: any): ArrayContains;

// @beta
export function arrayContains(array: string, element: Expr): ArrayContains;

// @beta
export function arrayContains(array: string, element: any): ArrayContains;

// @beta (undocumented)
export class ArrayContainsAll extends FirestoreFunction implements FilterCondition {
    constructor(array: Expr, values: Expr[]);
    // (undocumented)
    filterable: true;
    }

// @beta
export function arrayContainsAll(array: Expr, values: Expr[]): ArrayContainsAll;

// @beta
export function arrayContainsAll(array: Expr, values: any[]): ArrayContainsAll;

// @beta
export function arrayContainsAll(array: string, values: Expr[]): ArrayContainsAll;

// @beta
export function arrayContainsAll(array: string, values: any[]): ArrayContainsAll;

// @beta (undocumented)
export class ArrayContainsAny extends FirestoreFunction implements FilterCondition {
    constructor(array: Expr, values: Expr[]);
    // (undocumented)
    filterable: true;
    }

// @beta
export function arrayContainsAny(array: Expr, values: Expr[]): ArrayContainsAny;

// @beta
export function arrayContainsAny(array: Expr, values: any[]): ArrayContainsAny;

// @beta
export function arrayContainsAny(array: string, values: Expr[]): ArrayContainsAny;

// @beta
export function arrayContainsAny(array: string, values: any[]): ArrayContainsAny;

// @beta (undocumented)
export class ArrayElement extends FirestoreFunction {
    constructor();
}

// @beta (undocumented)
export class ArrayLength extends FirestoreFunction {
    constructor(array: Expr);
    }

// @beta
export function arrayLength(array: Expr): ArrayLength;

// @public
export function arrayRemove(...elements: unknown[]): FieldValue;

// @beta (undocumented)
export class ArrayReverse extends FirestoreFunction {
    constructor(array: Expr);
    }

// @public
export function arrayUnion(...elements: unknown[]): FieldValue;

// @beta
export function ascending(expr: Expr): Ordering;

// @public
export function average(field: string | FieldPath): AggregateField<number | null>;

// @beta (undocumented)
export class Avg extends FirestoreFunction implements Accumulator {
    constructor(value: Expr, distinct: boolean);
    // (undocumented)
    accumulator: true;
    }

// @beta
export function avgFunction(value: Expr): Avg;

// @beta
export function avgFunction(value: string): Avg;

// @beta (undocumented)
export class ByteLength extends FirestoreFunction {
    constructor(value: Expr);
    }

// @beta
export function byteLength(expr: Expr): ByteLength;

// @beta
export function byteLength(field: string): ByteLength;

// @public
export class Bytes {
    static fromBase64String(base64: string): Bytes;
    static fromUint8Array(array: Uint8Array): Bytes;
    isEqual(other: Bytes): boolean;
    toBase64(): string;
    toString(): string;
    toUint8Array(): Uint8Array;
}

// @public
export const CACHE_SIZE_UNLIMITED = -1;

// @beta (undocumented)
export class CharLength extends FirestoreFunction {
    constructor(value: Expr);
    }

// @beta
export function charLength(field: string): CharLength;

// @beta
export function charLength(expr: Expr): CharLength;

// @public
export type ChildUpdateFields<K extends string, V> = V extends Record<string, unknown> ? AddPrefixToKeys<K, UpdateData<V>> : never;

// @public
export function clearIndexedDbPersistence(firestore: Firestore): Promise<void>;

// @public
export function collection(firestore: Firestore, path: string, ...pathSegments: string[]): CollectionReference<DocumentData, DocumentData>;

// @public
export function collection<AppModelType, DbModelType extends DocumentData>(reference: CollectionReference<AppModelType, DbModelType>, path: string, ...pathSegments: string[]): CollectionReference<DocumentData, DocumentData>;

// @public
export function collection<AppModelType, DbModelType extends DocumentData>(reference: DocumentReference<AppModelType, DbModelType>, path: string, ...pathSegments: string[]): CollectionReference<DocumentData, DocumentData>;

// @public
export function collectionGroup(firestore: Firestore, collectionId: string): Query<DocumentData, DocumentData>;

// @beta (undocumented)
export class CollectionGroupSource implements Stage {
    constructor(collectionId: string);
    // (undocumented)
    name: string;
}

// @public
export class CollectionReference<AppModelType = DocumentData, DbModelType extends DocumentData = DocumentData> extends Query<AppModelType, DbModelType> {
    get id(): string;
    get parent(): DocumentReference<DocumentData, DocumentData> | null;
    get path(): string;
    readonly type = "collection";
    withConverter<NewAppModelType, NewDbModelType extends DocumentData = DocumentData>(converter: FirestoreDataConverter<NewAppModelType, NewDbModelType>): CollectionReference<NewAppModelType, NewDbModelType>;
    withConverter(converter: null): CollectionReference<DocumentData, DocumentData>;
}

// @beta (undocumented)
export class CollectionSource implements Stage {
    constructor(collectionPath: string);
    // (undocumented)
    name: string;
}

// @beta (undocumented)
export class Cond extends FirestoreFunction {
    constructor(condition: FilterCondition, thenExpr: Expr, elseExpr: Expr);
    // (undocumented)
    filterable: true;
    }

// @beta
export function cond(condition: FilterCondition, thenExpr: Expr, elseExpr: Expr): Cond;

// @public
export function connectFirestoreEmulator(firestore: Firestore, host: string, port: number, options?: {
    mockUserToken?: EmulatorMockTokenOptions | string;
}): void;

// @beta
export class Constant extends Expr {
    // (undocumented)
    exprType: ExprType;
    static of(value: number): Constant;
    static of(value: string): Constant;
    static of(value: boolean): Constant;
    static of(value: null): Constant;
    static of(value: undefined): Constant;
    static of(value: GeoPoint): Constant;
    static of(value: Timestamp): Constant;
    static of(value: Date): Constant;
    static of(value: Uint8Array): Constant;
    static of(value: DocumentReference): Constant;
    static of(value: any[]): Constant;
    static of(value: Map<string, any>): Constant;
    static of(value: VectorValue): Constant;
    static vector(value: number[] | VectorValue): Constant;
}

// @beta (undocumented)
export class CosineDistance extends FirestoreFunction {
    constructor(vector1: Expr, vector2: Expr);
    }

// @beta
export function cosineDistance(expr: string, other: number[]): CosineDistance;

// @beta
export function cosineDistance(expr: string, other: VectorValue): CosineDistance;

// @beta
export function cosineDistance(expr: string, other: Expr): CosineDistance;

// @beta
export function cosineDistance(expr: Expr, other: number[]): CosineDistance;

// @beta
export function cosineDistance(expr: Expr, other: VectorValue): CosineDistance;

// @beta
export function cosineDistance(expr: Expr, other: Expr): CosineDistance;

// @beta (undocumented)
export class Count extends FirestoreFunction implements Accumulator {
    constructor(value: Expr | undefined, distinct: boolean);
    // (undocumented)
    accumulator: true;
    }

// @public
export function count(): AggregateField<number>;

// @beta
export function countAll(): Count;

// @beta
export function countFunction(value: Expr): Count;

// Warning: (ae-incompatible-release-tags) The symbol "countFunction" is marked as @public, but its signature references "Count" which is marked as @beta
//
// @public
export function countFunction(value: string): Count;

// @beta (undocumented)
export class DatabaseSource implements Stage {
    // (undocumented)
    name: string;
}

// @public
export function deleteAllPersistentCacheIndexes(indexManager: PersistentCacheIndexManager): void;

// @public
export function deleteDoc<AppModelType, DbModelType extends DocumentData>(reference: DocumentReference<AppModelType, DbModelType>): Promise<void>;

// @public
export function deleteField(): FieldValue;

// @beta
export function descending(expr: Expr): Ordering;

// @public
export function disableNetwork(firestore: Firestore): Promise<void>;

// @public
export function disablePersistentCacheIndexAutoCreation(indexManager: PersistentCacheIndexManager): void;

// @beta (undocumented)
export class Distinct implements Stage {
    constructor(groups: Map<string, Expr>);
    // (undocumented)
    name: string;
}

// @beta (undocumented)
export class Divide extends FirestoreFunction {
    constructor(left: Expr, right: Expr);
    }

// @beta
export function divide(left: Expr, right: Expr): Divide;

// @beta
export function divide(left: Expr, right: any): Divide;

// @beta
export function divide(left: string, right: Expr): Divide;

// @beta
export function divide(left: string, right: any): Divide;

// @public
export function doc(firestore: Firestore, path: string, ...pathSegments: string[]): DocumentReference<DocumentData, DocumentData>;

// @public
export function doc<AppModelType, DbModelType extends DocumentData>(reference: CollectionReference<AppModelType, DbModelType>, path?: string, ...pathSegments: string[]): DocumentReference<AppModelType, DbModelType>;

// @public
export function doc<AppModelType, DbModelType extends DocumentData>(reference: DocumentReference<AppModelType, DbModelType>, path: string, ...pathSegments: string[]): DocumentReference<DocumentData, DocumentData>;

// @public
export interface DocumentChange<AppModelType = DocumentData, DbModelType extends DocumentData = DocumentData> {
    readonly doc: QueryDocumentSnapshot<AppModelType, DbModelType>;
    readonly newIndex: number;
    readonly oldIndex: number;
    readonly type: DocumentChangeType;
}

// @public
export type DocumentChangeType = 'added' | 'removed' | 'modified';

// @public
export interface DocumentData {
    [field: string]: any;
}

// @public
export function documentId(): FieldPath;

// @public
export class DocumentReference<AppModelType = DocumentData, DbModelType extends DocumentData = DocumentData> {
    readonly converter: FirestoreDataConverter<AppModelType, DbModelType> | null;
    readonly firestore: Firestore;
    get id(): string;
    get parent(): CollectionReference<AppModelType, DbModelType>;
    get path(): string;
    readonly type = "document";
    withConverter<NewAppModelType, NewDbModelType extends DocumentData = DocumentData>(converter: FirestoreDataConverter<NewAppModelType, NewDbModelType>): DocumentReference<NewAppModelType, NewDbModelType>;
    withConverter(converter: null): DocumentReference<DocumentData, DocumentData>;
}

// @public
export class DocumentSnapshot<AppModelType = DocumentData, DbModelType extends DocumentData = DocumentData> {
    protected constructor();
    data(options?: SnapshotOptions): AppModelType | undefined;
    exists(): this is QueryDocumentSnapshot<AppModelType, DbModelType>;
    get(fieldPath: string | FieldPath, options?: SnapshotOptions): any;
    get id(): string;
    readonly metadata: SnapshotMetadata;
    get ref(): DocumentReference<AppModelType, DbModelType>;
}

// @beta (undocumented)
export class DocumentsSource implements Stage {
    constructor(docPaths: string[]);
    // (undocumented)
    name: string;
    // (undocumented)
    static of(refs: DocumentReference[]): DocumentsSource;
}

// @beta (undocumented)
export class DotProduct extends FirestoreFunction {
    constructor(vector1: Expr, vector2: Expr);
    }

// @beta
export function dotProduct(expr: string, other: number[]): DotProduct;

// @beta
export function dotProduct(expr: string, other: VectorValue): DotProduct;

// @beta
export function dotProduct(expr: string, other: Expr): DotProduct;

// @beta
export function dotProduct(expr: Expr, other: number[]): DotProduct;

// @beta
export function dotProduct(expr: Expr, other: VectorValue): DotProduct;

// @beta
export function dotProduct(expr: Expr, other: Expr): DotProduct;

export { EmulatorMockTokenOptions }

// @public @deprecated
export function enableIndexedDbPersistence(firestore: Firestore, persistenceSettings?: PersistenceSettings): Promise<void>;

// @public @deprecated
export function enableMultiTabIndexedDbPersistence(firestore: Firestore): Promise<void>;

// @public
export function enableNetwork(firestore: Firestore): Promise<void>;

// @public
export function enablePersistentCacheIndexAutoCreation(indexManager: PersistentCacheIndexManager): void;

// @public
export function endAt<AppModelType, DbModelType extends DocumentData>(snapshot: DocumentSnapshot<AppModelType, DbModelType>): QueryEndAtConstraint;

// @public
export function endAt(...fieldValues: unknown[]): QueryEndAtConstraint;

// @public
export function endBefore<AppModelType, DbModelType extends DocumentData>(snapshot: DocumentSnapshot<AppModelType, DbModelType>): QueryEndAtConstraint;

// @public
export function endBefore(...fieldValues: unknown[]): QueryEndAtConstraint;

// @beta (undocumented)
export class EndsWith extends FirestoreFunction implements FilterCondition {
    constructor(expr: Expr, suffix: Expr);
    // (undocumented)
    filterable: true;
    }

// @beta
export function endsWith(expr: string, suffix: string): EndsWith;

// @beta
export function endsWith(expr: string, suffix: Expr): EndsWith;

// @beta
export function endsWith(expr: Expr, suffix: string): EndsWith;

// @beta
export function endsWith(expr: Expr, suffix: Expr): EndsWith;

// @beta (undocumented)
export class Eq extends FirestoreFunction implements FilterCondition {
    constructor(left: Expr, right: Expr);
    // (undocumented)
    filterable: true;
    }

// @beta
export function eq(left: Expr, right: Expr): Eq;

// @beta
export function eq(left: Expr, right: any): Eq;

// @beta
export function eq(left: string, right: Expr): Eq;

// @beta
export function eq(left: string, right: any): Eq;

// @beta (undocumented)
export class EqAny extends FirestoreFunction implements FilterCondition {
    constructor(left: Expr, others: Expr[]);
    // (undocumented)
    filterable: true;
    }

// @beta
export function eqAny(element: Expr, others: Expr[]): EqAny;

// @beta
export function eqAny(element: Expr, others: any[]): EqAny;

// @beta
export function eqAny(element: string, others: Expr[]): EqAny;

// @beta
export function eqAny(element: string, others: any[]): EqAny;

// @beta (undocumented)
export class EuclideanDistance extends FirestoreFunction {
    constructor(vector1: Expr, vector2: Expr);
    }

// @beta
export function euclideanDistance(expr: string, other: number[]): EuclideanDistance;

// @beta
export function euclideanDistance(expr: string, other: VectorValue): EuclideanDistance;

// @beta
export function euclideanDistance(expr: string, other: Expr): EuclideanDistance;

// @beta
export function euclideanDistance(expr: Expr, other: number[]): EuclideanDistance;

// @beta
export function euclideanDistance(expr: Expr, other: VectorValue): EuclideanDistance;

// @beta
export function euclideanDistance(expr: Expr, other: Expr): EuclideanDistance;

// Warning: (ae-incompatible-release-tags) The symbol "execute" is marked as @public, but its signature references "PipelineResult" which is marked as @beta
//
// @public (undocumented)
export function execute(pipeline: Pipeline): Promise<PipelineResult[]>;

// @beta (undocumented)
export class Exists extends FirestoreFunction implements FilterCondition {
    constructor(expr: Expr);
    // (undocumented)
    filterable: true;
}

// @beta
export function exists(value: Expr): Exists;

// @beta
export function exists(field: string): Exists;

// @public
export interface ExperimentalLongPollingOptions {
    timeoutSeconds?: number;
}

// @beta
export abstract class Expr {
    add(other: Expr): Add;
    add(other: any): Add;
    arrayConcat(...arrays: Expr[]): ArrayConcat;
    arrayConcat(...arrays: any[][]): ArrayConcat;
    arrayContains(element: Expr): ArrayContains;
    arrayContains(element: any): ArrayContains;
    arrayContainsAll(...values: Expr[]): ArrayContainsAll;
    arrayContainsAll(...values: any[]): ArrayContainsAll;
    arrayContainsAny(...values: Expr[]): ArrayContainsAny;
    arrayContainsAny(...values: any[]): ArrayContainsAny;
    arrayLength(): ArrayLength;
    as(name: string): ExprWithAlias<this>;
    ascending(): Ordering;
    avg(): Avg;
    byteLength(): ByteLength;
    charLength(): CharLength;
    cosineDistance(other: Expr): CosineDistance;
    cosineDistance(other: VectorValue): CosineDistance;
    cosineDistance(other: number[]): CosineDistance;
    count(): Count;
    descending(): Ordering;
    divide(other: Expr): Divide;
    divide(other: any): Divide;
    dotProduct(other: Expr): DotProduct;
    dotProduct(other: VectorValue): DotProduct;
    dotProduct(other: number[]): DotProduct;
    endsWith(suffix: string): EndsWith;
    endsWith(suffix: Expr): EndsWith;
    eq(other: Expr): Eq;
    eq(other: any): Eq;
    eqAny(...others: Expr[]): EqAny;
    eqAny(...others: any[]): EqAny;
    euclideanDistance(other: Expr): EuclideanDistance;
    euclideanDistance(other: VectorValue): EuclideanDistance;
    euclideanDistance(other: number[]): EuclideanDistance;
    exists(): Exists;
    // (undocumented)
    abstract exprType: ExprType;
    gt(other: Expr): Gt;
    gt(other: any): Gt;
    gte(other: Expr): Gte;
    gte(other: any): Gte;
    isNaN(): IsNan;
    like(pattern: string): Like;
    like(pattern: Expr): Like;
    logicalMaximum(other: Expr): LogicalMaximum;
    logicalMaximum(other: any): LogicalMaximum;
    logicalMinimum(other: Expr): LogicalMinimum;
    logicalMinimum(other: any): LogicalMinimum;
    lt(other: Expr): Lt;
    lt(other: any): Lt;
    lte(other: Expr): Lte;
    lte(other: any): Lte;
    mapGet(subfield: string): MapGet;
    maximum(): Maximum;
    minimum(): Minimum;
    mod(other: Expr): Mod;
    mod(other: any): Mod;
    multiply(other: Expr): Multiply;
    multiply(other: any): Multiply;
    neq(other: Expr): Neq;
    neq(other: any): Neq;
    notEqAny(...others: Expr[]): NotEqAny;
    notEqAny(...others: any[]): NotEqAny;
    regexContains(pattern: string): RegexContains;
    regexContains(pattern: Expr): RegexContains;
    regexMatch(pattern: string): RegexMatch;
    regexMatch(pattern: Expr): RegexMatch;
    replaceAll(find: string, replace: string): ReplaceAll;
    replaceAll(find: Expr, replace: Expr): ReplaceAll;
    replaceFirst(find: string, replace: string): ReplaceFirst;
    replaceFirst(find: Expr, replace: Expr): ReplaceFirst;
    reverse(): Reverse;
    startsWith(prefix: string): StartsWith;
    startsWith(prefix: Expr): StartsWith;
    strConcat(...elements: Array<string | Expr>): StrConcat;
    strContains(substring: string): StrContains;
    strContains(expr: Expr): StrContains;
    subtract(other: Expr): Subtract;
    subtract(other: any): Subtract;
    sum(): Sum;
    timestampAdd(unit: Expr, amount: Expr): TimestampAdd;
    timestampAdd(unit: 'microsecond' | 'millisecond' | 'second' | 'minute' | 'hour' | 'day', amount: number): TimestampAdd;
    timestampSub(unit: Expr, amount: Expr): TimestampSub;
    timestampSub(unit: 'microsecond' | 'millisecond' | 'second' | 'minute' | 'hour' | 'day', amount: number): TimestampSub;
    timestampToUnixMicros(): TimestampToUnixMicros;
    timestampToUnixMillis(): TimestampToUnixMillis;
    timestampToUnixSeconds(): TimestampToUnixSeconds;
    toLower(): ToLower;
    toUpper(): ToUpper;
    trim(): Trim;
    unixMicrosToTimestamp(): UnixMicrosToTimestamp;
    unixMillisToTimestamp(): UnixMillisToTimestamp;
    unixSecondsToTimestamp(): UnixSecondsToTimestamp;
    vectorLength(): VectorLength;
}

// @beta
export type ExprType = 'Field' | 'Constant' | 'Function' | 'ListOfExprs' | 'ExprWithAlias';

// @beta (undocumented)
export class ExprWithAlias<T extends Expr> extends Expr implements Selectable {
    constructor(expr: T, alias: string);
    // (undocumented)
    readonly alias: string;
    // (undocumented)
    readonly expr: T;
    // (undocumented)
    exprType: ExprType;
    // (undocumented)
    selectable: true;
}

// @beta
export class Field extends Expr implements Selectable {
    // (undocumented)
    exprType: ExprType;
    // (undocumented)
    fieldName(): string;
    static of(name: string): Field;
    // (undocumented)
    static of(path: FieldPath): Field;
    // (undocumented)
    static of(pipeline: Pipeline, name: string): Field;
    // (undocumented)
    selectable: true;
}

// @public
export class FieldPath {
    constructor(...fieldNames: string[]);
    isEqual(other: FieldPath): boolean;
}

// @beta (undocumented)
export class Fields extends Expr implements Selectable {
    // (undocumented)
    exprType: ExprType;
    // (undocumented)
    fieldList(): Field[];
    // (undocumented)
    static of(name: string, ...others: string[]): Fields;
    // (undocumented)
    static ofAll(): Fields;
    // (undocumented)
    selectable: true;
}

// @public
export abstract class FieldValue {
    abstract isEqual(other: FieldValue): boolean;
}

// @beta
export interface FilterCondition extends Expr {
    // (undocumented)
    filterable: true;
}

// @beta (undocumented)
export class FindNearest implements Stage {
    // (undocumented)
    name: string;
}

// @beta (undocumented)
export interface FindNearestOptions {
    // (undocumented)
    distanceField?: string;
    // (undocumented)
    distanceMeasure: 'euclidean' | 'cosine' | 'dot_product';
    // (undocumented)
    field: Field;
    // (undocumented)
    limit?: number;
    // (undocumented)
    vectorValue: VectorValue | number[];
}

// @public
export class Firestore {
    get app(): FirebaseApp;
    toJSON(): object;
    type: 'firestore-lite' | 'firestore';
}

// @public
export interface FirestoreDataConverter<AppModelType, DbModelType extends DocumentData = DocumentData> {
    fromFirestore(snapshot: QueryDocumentSnapshot<DocumentData, DocumentData>, options?: SnapshotOptions): AppModelType;
    toFirestore(modelObject: WithFieldValue<AppModelType>): WithFieldValue<DbModelType>;
    toFirestore(modelObject: PartialWithFieldValue<AppModelType>, options: SetOptions): PartialWithFieldValue<DbModelType>;
}

// @public
export class FirestoreError extends FirebaseError {
    readonly code: FirestoreErrorCode;
    readonly message: string;
    readonly stack?: string;
}

// @public
export type FirestoreErrorCode = 'cancelled' | 'unknown' | 'invalid-argument' | 'deadline-exceeded' | 'not-found' | 'already-exists' | 'permission-denied' | 'resource-exhausted' | 'failed-precondition' | 'aborted' | 'out-of-range' | 'unimplemented' | 'internal' | 'unavailable' | 'data-loss' | 'unauthenticated';

// @beta
export class FirestoreFunction extends Expr {
    constructor(name: string, params: Expr[]);
    // (undocumented)
    exprType: ExprType;
    }

// @public
export type FirestoreLocalCache = MemoryLocalCache | PersistentLocalCache;

// @public
export interface FirestoreSettings {
    cacheSizeBytes?: number;
    experimentalAutoDetectLongPolling?: boolean;
    experimentalForceLongPolling?: boolean;
    experimentalLongPollingOptions?: ExperimentalLongPollingOptions;
    host?: string;
    ignoreUndefinedProperties?: boolean;
    localCache?: FirestoreLocalCache;
    ssl?: boolean;
}

// @beta
export function genericFunction(name: string, params: Expr[]): FirestoreFunction;

// @beta (undocumented)
export class GenericStage implements Stage {
    constructor(name: string, params: unknown[]);
    // (undocumented)
    name: string;
}

// @public
export class GeoPoint {
    constructor(latitude: number, longitude: number);
    isEqual(other: GeoPoint): boolean;
    get latitude(): number;
    get longitude(): number;
    toJSON(): {
        latitude: number;
        longitude: number;
    };
}

// @public
export function getAggregateFromServer<AggregateSpecType extends AggregateSpec, AppModelType, DbModelType extends DocumentData>(query: Query<AppModelType, DbModelType>, aggregateSpec: AggregateSpecType): Promise<AggregateQuerySnapshot<AggregateSpecType, AppModelType, DbModelType>>;

// @public
export function getCountFromServer<AppModelType, DbModelType extends DocumentData>(query: Query<AppModelType, DbModelType>): Promise<AggregateQuerySnapshot<{
    count: AggregateField<number>;
}, AppModelType, DbModelType>>;

// @public
export function getDoc<AppModelType, DbModelType extends DocumentData>(reference: DocumentReference<AppModelType, DbModelType>): Promise<DocumentSnapshot<AppModelType, DbModelType>>;

// @public
export function getDocFromCache<AppModelType, DbModelType extends DocumentData>(reference: DocumentReference<AppModelType, DbModelType>): Promise<DocumentSnapshot<AppModelType, DbModelType>>;

// @public
export function getDocFromServer<AppModelType, DbModelType extends DocumentData>(reference: DocumentReference<AppModelType, DbModelType>): Promise<DocumentSnapshot<AppModelType, DbModelType>>;

// @public
export function getDocs<AppModelType, DbModelType extends DocumentData>(query: Query<AppModelType, DbModelType>): Promise<QuerySnapshot<AppModelType, DbModelType>>;

// @public
export function getDocsFromCache<AppModelType, DbModelType extends DocumentData>(query: Query<AppModelType, DbModelType>): Promise<QuerySnapshot<AppModelType, DbModelType>>;

// @public
export function getDocsFromServer<AppModelType, DbModelType extends DocumentData>(query: Query<AppModelType, DbModelType>): Promise<QuerySnapshot<AppModelType, DbModelType>>;

// @public
export function getFirestore(): Firestore;

// @public
export function getFirestore(app: FirebaseApp): Firestore;

// @beta
export function getFirestore(databaseId: string): Firestore;

// @beta
export function getFirestore(app: FirebaseApp, databaseId: string): Firestore;

// @public
export function getPersistentCacheIndexManager(firestore: Firestore): PersistentCacheIndexManager | null;

// @beta (undocumented)
export class Gt extends FirestoreFunction implements FilterCondition {
    constructor(left: Expr, right: Expr);
    // (undocumented)
    filterable: true;
    }

// @beta
export function gt(left: Expr, right: Expr): Gt;

// @beta
export function gt(left: Expr, right: any): Gt;

// @beta
export function gt(left: string, right: Expr): Gt;

// @beta
export function gt(left: string, right: any): Gt;

// @beta (undocumented)
export class Gte extends FirestoreFunction implements FilterCondition {
    constructor(left: Expr, right: Expr);
    // (undocumented)
    filterable: true;
    }

// @beta
export function gte(left: Expr, right: Expr): Gte;

// @beta
export function gte(left: Expr, right: any): Gte;

// @beta
export function gte(left: string, right: Expr): Gte;

// @beta
export function gte(left: string, right: any): Gte;

// @public
export function increment(n: number): FieldValue;

// @beta @deprecated
export interface Index {
    // (undocumented)
    [key: string]: unknown;
    readonly collectionGroup: string;
    readonly fields?: IndexField[];
}

// @beta @deprecated
export interface IndexConfiguration {
    // (undocumented)
    [key: string]: unknown;
    readonly indexes?: Index[];
}

// @beta @deprecated
export interface IndexField {
    // (undocumented)
    [key: string]: unknown;
    readonly arrayConfig?: 'CONTAINS';
    readonly fieldPath: string;
    readonly order?: 'ASCENDING' | 'DESCENDING';
}

// @public
export function initializeFirestore(app: FirebaseApp, settings: FirestoreSettings, databaseId?: string): Firestore;

// @beta (undocumented)
export class IsNan extends FirestoreFunction implements FilterCondition {
    constructor(expr: Expr);
    // (undocumented)
    filterable: true;
}

// @beta
export function isNan(value: Expr): IsNan;

// @beta
export function isNan(value: string): IsNan;

// @beta (undocumented)
export class Like extends FirestoreFunction implements FilterCondition {
    constructor(expr: Expr, pattern: Expr);
    // (undocumented)
    filterable: true;
    }

// @beta
export function like(left: string, pattern: string): Like;

// @beta
export function like(left: string, pattern: Expr): Like;

// @beta
export function like(left: Expr, pattern: string): Like;

// @beta
export function like(left: Expr, pattern: Expr): Like;

// @beta (undocumented)
export class Limit implements Stage {
    constructor(limit: number);
    // (undocumented)
    name: string;
}

// @public
export function limit(limit: number): QueryLimitConstraint;

// @public
export function limitToLast(limit: number): QueryLimitConstraint;

// @public
export type ListenSource = 'default' | 'cache';

// @public
export function loadBundle(firestore: Firestore, bundleData: ReadableStream<Uint8Array> | ArrayBuffer | string): LoadBundleTask;

// @public
export class LoadBundleTask implements PromiseLike<LoadBundleTaskProgress> {
    catch<R>(onRejected: (a: Error) => R | PromiseLike<R>): Promise<R | LoadBundleTaskProgress>;
    onProgress(next?: (progress: LoadBundleTaskProgress) => unknown, error?: (err: Error) => unknown, complete?: () => void): void;
    then<T, R>(onFulfilled?: (a: LoadBundleTaskProgress) => T | PromiseLike<T>, onRejected?: (a: Error) => R | PromiseLike<R>): Promise<T | R>;
}

// @public
export interface LoadBundleTaskProgress {
    bytesLoaded: number;
    documentsLoaded: number;
    taskState: TaskState;
    totalBytes: number;
    totalDocuments: number;
}

// @beta (undocumented)
export class LogicalMaximum extends FirestoreFunction {
    constructor(left: Expr, right: Expr);
    }

// @beta
export function logicalMaximum(left: Expr, right: Expr): LogicalMaximum;

// @beta
export function logicalMaximum(left: Expr, right: any): LogicalMaximum;

// @beta
export function logicalMaximum(left: string, right: Expr): LogicalMaximum;

// @beta
export function logicalMaximum(left: string, right: any): LogicalMaximum;

// @beta (undocumented)
export class LogicalMinimum extends FirestoreFunction {
    constructor(left: Expr, right: Expr);
    }

// @beta
export function logicalMinimum(left: Expr, right: Expr): LogicalMinimum;

// @beta
export function logicalMinimum(left: Expr, right: any): LogicalMinimum;

// @beta
export function logicalMinimum(left: string, right: Expr): LogicalMinimum;

// @beta
export function logicalMinimum(left: string, right: any): LogicalMinimum;

export { LogLevel }

// @beta (undocumented)
export class Lt extends FirestoreFunction implements FilterCondition {
    constructor(left: Expr, right: Expr);
    // (undocumented)
    filterable: true;
    }

// @beta
export function lt(left: Expr, right: Expr): Lt;

// @beta
export function lt(left: Expr, right: any): Lt;

// @beta
export function lt(left: string, right: Expr): Lt;

// @beta
export function lt(left: string, right: any): Lt;

// @beta (undocumented)
export class Lte extends FirestoreFunction implements FilterCondition {
    constructor(left: Expr, right: Expr);
    // (undocumented)
    filterable: true;
    }

// @beta
export function lte(left: Expr, right: Expr): Lte;

// @beta
export function lte(left: Expr, right: any): Lte;

// Warning: (ae-incompatible-release-tags) The symbol "lte" is marked as @public, but its signature references "Expr" which is marked as @beta
// Warning: (ae-incompatible-release-tags) The symbol "lte" is marked as @public, but its signature references "Lte" which is marked as @beta
//
// @public
export function lte(left: string, right: Expr): Lte;

// @beta
export function lte(left: string, right: any): Lte;

// @beta (undocumented)
export class MapGet extends FirestoreFunction {
    constructor(map: Expr, name: string);
}

// @beta
export function mapGet(mapField: string, subField: string): MapGet;

// @beta
export function mapGet(mapExpr: Expr, subField: string): MapGet;

// @beta (undocumented)
export class Maximum extends FirestoreFunction implements Accumulator {
    constructor(value: Expr, distinct: boolean);
    // (undocumented)
    accumulator: true;
    }

// @beta
export function maximum(value: Expr): Maximum;

// @beta
export function maximum(value: string): Maximum;

// @public
export interface MemoryCacheSettings {
    garbageCollector?: MemoryGarbageCollector;
}

// @public
export interface MemoryEagerGarbageCollector {
    // (undocumented)
    kind: 'memoryEager';
}

// @public
export function memoryEagerGarbageCollector(): MemoryEagerGarbageCollector;

// @public
export type MemoryGarbageCollector = MemoryEagerGarbageCollector | MemoryLruGarbageCollector;

// @public
export interface MemoryLocalCache {
    // (undocumented)
    kind: 'memory';
}

// @public
export function memoryLocalCache(settings?: MemoryCacheSettings): MemoryLocalCache;

// @public
export interface MemoryLruGarbageCollector {
    // (undocumented)
    kind: 'memoryLru';
}

// @public
export function memoryLruGarbageCollector(settings?: {
    cacheSizeBytes?: number;
}): MemoryLruGarbageCollector;

// @beta (undocumented)
export class Minimum extends FirestoreFunction implements Accumulator {
    constructor(value: Expr, distinct: boolean);
    // (undocumented)
    accumulator: true;
    }

// @beta
export function minimum(value: Expr): Minimum;

// @beta
export function minimum(value: string): Minimum;

// @beta (undocumented)
export class Mod extends FirestoreFunction {
    constructor(left: Expr, right: Expr);
    }

// @beta
export function mod(left: Expr, right: Expr): Mod;

// @beta
export function mod(left: Expr, right: any): Mod;

// @beta
export function mod(left: string, right: Expr): Mod;

// @beta
export function mod(left: string, right: any): Mod;

// @beta (undocumented)
export class Multiply extends FirestoreFunction {
    constructor(left: Expr, right: Expr);
    }

// @beta
export function multiply(left: Expr, right: Expr): Multiply;

// @beta
export function multiply(left: Expr, right: any): Multiply;

// @beta
export function multiply(left: string, right: Expr): Multiply;

// @beta
export function multiply(left: string, right: any): Multiply;

// @public
export function namedQuery(firestore: Firestore, name: string): Promise<Query | null>;

// @beta (undocumented)
export class Neq extends FirestoreFunction implements FilterCondition {
    constructor(left: Expr, right: Expr);
    // (undocumented)
    filterable: true;
    }

// @beta
export function neq(left: Expr, right: Expr): Neq;

// @beta
export function neq(left: Expr, right: any): Neq;

// @beta
export function neq(left: string, right: Expr): Neq;

// @beta
export function neq(left: string, right: any): Neq;

// @public
export type NestedUpdateFields<T extends Record<string, unknown>> = UnionToIntersection<{
    [K in keyof T & string]: ChildUpdateFields<K, T[K]>;
}[keyof T & string]>;

// @beta (undocumented)
export class Not extends FirestoreFunction implements FilterCondition {
    constructor(expr: Expr);
    // (undocumented)
    filterable: true;
}

// @beta
export function not(filter: FilterCondition): Not;

// @beta (undocumented)
export class NotEqAny extends FirestoreFunction implements FilterCondition {
    constructor(left: Expr, others: Expr[]);
    // (undocumented)
    filterable: true;
    }

// @beta
export function notEqAny(element: Expr, others: Expr[]): NotEqAny;

// @beta
export function notEqAny(element: Expr, others: any[]): NotEqAny;

// @beta
export function notEqAny(element: string, others: Expr[]): NotEqAny;

// @beta
export function notEqAny(element: string, others: any[]): NotEqAny;

// @beta (undocumented)
export class Offset implements Stage {
    constructor(offset: number);
    // (undocumented)
    name: string;
    }

// @public
export function onSnapshot<AppModelType, DbModelType extends DocumentData>(reference: DocumentReference<AppModelType, DbModelType>, observer: {
    next?: (snapshot: DocumentSnapshot<AppModelType, DbModelType>) => void;
    error?: (error: FirestoreError) => void;
    complete?: () => void;
}): Unsubscribe;

// @public
export function onSnapshot<AppModelType, DbModelType extends DocumentData>(reference: DocumentReference<AppModelType, DbModelType>, options: SnapshotListenOptions, observer: {
    next?: (snapshot: DocumentSnapshot<AppModelType, DbModelType>) => void;
    error?: (error: FirestoreError) => void;
    complete?: () => void;
}): Unsubscribe;

// @public
export function onSnapshot<AppModelType, DbModelType extends DocumentData>(reference: DocumentReference<AppModelType, DbModelType>, onNext: (snapshot: DocumentSnapshot<AppModelType, DbModelType>) => void, onError?: (error: FirestoreError) => void, onCompletion?: () => void): Unsubscribe;

// @public
export function onSnapshot<AppModelType, DbModelType extends DocumentData>(reference: DocumentReference<AppModelType, DbModelType>, options: SnapshotListenOptions, onNext: (snapshot: DocumentSnapshot<AppModelType, DbModelType>) => void, onError?: (error: FirestoreError) => void, onCompletion?: () => void): Unsubscribe;

// @public
export function onSnapshot<AppModelType, DbModelType extends DocumentData>(query: Query<AppModelType, DbModelType>, observer: {
    next?: (snapshot: QuerySnapshot<AppModelType, DbModelType>) => void;
    error?: (error: FirestoreError) => void;
    complete?: () => void;
}): Unsubscribe;

// @public
export function onSnapshot<AppModelType, DbModelType extends DocumentData>(query: Query<AppModelType, DbModelType>, options: SnapshotListenOptions, observer: {
    next?: (snapshot: QuerySnapshot<AppModelType, DbModelType>) => void;
    error?: (error: FirestoreError) => void;
    complete?: () => void;
}): Unsubscribe;

// @public
export function onSnapshot<AppModelType, DbModelType extends DocumentData>(query: Query<AppModelType, DbModelType>, onNext: (snapshot: QuerySnapshot<AppModelType, DbModelType>) => void, onError?: (error: FirestoreError) => void, onCompletion?: () => void): Unsubscribe;

// @public
export function onSnapshot<AppModelType, DbModelType extends DocumentData>(query: Query<AppModelType, DbModelType>, options: SnapshotListenOptions, onNext: (snapshot: QuerySnapshot<AppModelType, DbModelType>) => void, onError?: (error: FirestoreError) => void, onCompletion?: () => void): Unsubscribe;

// @public
export function onSnapshotsInSync(firestore: Firestore, observer: {
    next?: (value: void) => void;
    error?: (error: FirestoreError) => void;
    complete?: () => void;
}): Unsubscribe;

// @public
export function onSnapshotsInSync(firestore: Firestore, onSync: () => void): Unsubscribe;

// @beta (undocumented)
export class Or extends FirestoreFunction implements FilterCondition {
    constructor(conditions: (FilterCondition)[]);
    // (undocumented)
    filterable: true;
}

// @public
export function or(...queryConstraints: QueryFilterConstraint[]): QueryCompositeFilterConstraint;

// @public
export function orderBy(fieldPath: string | FieldPath, directionStr?: OrderByDirection): QueryOrderByConstraint;

// @public
export type OrderByDirection = 'desc' | 'asc';

// @beta
export class Ordering {
    constructor(expr: Expr, direction: 'ascending' | 'descending');
    // (undocumented)
    readonly direction: 'ascending' | 'descending';
    // (undocumented)
    readonly expr: Expr;
}

// @beta
export function orFunction(left: FilterCondition, ...right: (FilterCondition)[]): Or;

// @public
export type PartialWithFieldValue<T> = Partial<T> | (T extends Primitive ? T : T extends {} ? {
    [K in keyof T]?: PartialWithFieldValue<T[K]> | FieldValue;
} : never);

// @public
export interface PersistenceSettings {
    forceOwnership?: boolean;
}

// @public
export class PersistentCacheIndexManager {
    readonly type: 'PersistentCacheIndexManager';
}

// @public
export interface PersistentCacheSettings {
    cacheSizeBytes?: number;
    tabManager?: PersistentTabManager;
}

// @public
export interface PersistentLocalCache {
    // (undocumented)
    kind: 'persistent';
}

// @public
export function persistentLocalCache(settings?: PersistentCacheSettings): PersistentLocalCache;

// @public
export interface PersistentMultipleTabManager {
    // (undocumented)
    kind: 'PersistentMultipleTab';
}

// @public
export function persistentMultipleTabManager(): PersistentMultipleTabManager;

// @public
export interface PersistentSingleTabManager {
    // (undocumented)
    kind: 'persistentSingleTab';
}

// @public
export function persistentSingleTabManager(settings: PersistentSingleTabManagerSettings | undefined): PersistentSingleTabManager;

// @public
export interface PersistentSingleTabManagerSettings {
    forceOwnership?: boolean;
}

// @public
export type PersistentTabManager = PersistentSingleTabManager | PersistentMultipleTabManager;

// @public (undocumented)
export class Pipeline {
    /* Excluded from this release type: newPipeline */
    // Warning: (ae-incompatible-release-tags) The symbol "addFields" is marked as @public, but its signature references "Selectable" which is marked as @beta
    addFields(...fields: Selectable[]): Pipeline;
    // Warning: (ae-incompatible-release-tags) The symbol "aggregate" is marked as @public, but its signature references "AccumulatorTarget" which is marked as @beta
    aggregate(...accumulators: AccumulatorTarget[]): Pipeline;
    aggregate(options: { accumulators: AccumulatorTarget[]; groups?: Array<string | Selectable>; }): Pipeline;
    // Warning: (ae-incompatible-release-tags) The symbol "distinct" is marked as @public, but its signature references "Selectable" which is marked as @beta
    distinct(...groups: Array<string | (Selectable)>): Pipeline;
    // Warning: (ae-incompatible-release-tags) The symbol "execute" is marked as @public, but its signature references "PipelineResult" which is marked as @beta
    execute(): Promise<PipelineResult[]>;
    // Warning: (ae-incompatible-release-tags) The symbol "findNearest" is marked as @public, but its signature references "FindNearestOptions" which is marked as @beta
    //
    // (undocumented)
    findNearest(options: FindNearestOptions): Pipeline;
    genericStage(name: string, params: any[]): Pipeline;
    limit(limit: number): Pipeline;
    offset(offset: number): Pipeline;
    readUserData: any;
    // Warning: (ae-incompatible-release-tags) The symbol "select" is marked as @public, but its signature references "Selectable" which is marked as @beta
    select(...selections: Array<Selectable | string>): Pipeline;
    // (undocumented)
    selectablesToMap: any;
    // Warning: (ae-incompatible-release-tags) The symbol "sort" is marked as @public, but its signature references "Ordering" which is marked as @beta
    sort(...orderings: Ordering[]): Pipeline;
    // (undocumented)
    sort(options: { orderings: Ordering[]; }): Pipeline;
    // (undocumented)
    stages: any;
    // (undocumented)
    userDataReader: any;
    // Warning: (ae-incompatible-release-tags) The symbol "where" is marked as @public, but its signature references "FilterCondition" which is marked as @beta
    where(condition: FilterCondition): Pipeline;
}

// Warning: (ae-incompatible-release-tags) The symbol "pipeline" is marked as @public, but its signature references "PipelineSource" which is marked as @beta
//
// @public
export function pipeline(firestore: Firestore): PipelineSource<Pipeline>;

// @public
export function pipeline(query: Query): Pipeline;

// @beta
export class PipelineResult<AppModelType = DocumentData> {
    /* Excluded from this release type: _ref */
    /* Excluded from this release type: _fields */
    /* Excluded from this release type: __constructor */
    get createTime(): Timestamp | undefined;
    data(): AppModelType | undefined;
    get executionTime(): Timestamp;
    get(fieldPath: string | FieldPath): any;
    get id(): string | undefined;
    get ref(): DocumentReference | undefined;
    get updateTime(): Timestamp | undefined;
}

// @beta
export class PipelineSource<PipelineType> {
    /* Excluded from this release type: _createPipeline */
    /* Excluded from this release type: __constructor */
    // (undocumented)
    collection(collectionPath: string): PipelineType;
    // (undocumented)
    collectionGroup(collectionId: string): PipelineType;
    // (undocumented)
    database(): PipelineType;
    // (undocumented)
    documents(docs: DocumentReference[]): PipelineType;
}

// @public
export type Primitive = string | number | boolean | undefined | null;

// @public
export class Query<AppModelType = DocumentData, DbModelType extends DocumentData = DocumentData> {
    protected constructor();
    readonly converter: FirestoreDataConverter<AppModelType, DbModelType> | null;
    readonly firestore: Firestore;
    readonly type: 'query' | 'collection';
    withConverter(converter: null): Query<DocumentData, DocumentData>;
    withConverter<NewAppModelType, NewDbModelType extends DocumentData = DocumentData>(converter: FirestoreDataConverter<NewAppModelType, NewDbModelType>): Query<NewAppModelType, NewDbModelType>;
}

// @public
export function query<AppModelType, DbModelType extends DocumentData>(query: Query<AppModelType, DbModelType>, compositeFilter: QueryCompositeFilterConstraint, ...queryConstraints: QueryNonFilterConstraint[]): Query<AppModelType, DbModelType>;

// @public
export function query<AppModelType, DbModelType extends DocumentData>(query: Query<AppModelType, DbModelType>, ...queryConstraints: QueryConstraint[]): Query<AppModelType, DbModelType>;

// @public
export class QueryCompositeFilterConstraint {
    readonly type: 'or' | 'and';
}

// @public
export abstract class QueryConstraint {
    abstract readonly type: QueryConstraintType;
}

// @public
export type QueryConstraintType = 'where' | 'orderBy' | 'limit' | 'limitToLast' | 'startAt' | 'startAfter' | 'endAt' | 'endBefore';

// @public
export class QueryDocumentSnapshot<AppModelType = DocumentData, DbModelType extends DocumentData = DocumentData> extends DocumentSnapshot<AppModelType, DbModelType> {
    // @override
    data(options?: SnapshotOptions): AppModelType;
}

// @public
export class QueryEndAtConstraint extends QueryConstraint {
    readonly type: 'endBefore' | 'endAt';
}

// @public
export function queryEqual<AppModelType, DbModelType extends DocumentData>(left: Query<AppModelType, DbModelType>, right: Query<AppModelType, DbModelType>): boolean;

// @public
export class QueryFieldFilterConstraint extends QueryConstraint {
    readonly type = "where";
}

// @public
export type QueryFilterConstraint = QueryFieldFilterConstraint | QueryCompositeFilterConstraint;

// @public
export class QueryLimitConstraint extends QueryConstraint {
    readonly type: 'limit' | 'limitToLast';
}

// @public
export type QueryNonFilterConstraint = QueryOrderByConstraint | QueryLimitConstraint | QueryStartAtConstraint | QueryEndAtConstraint;

// @public
export class QueryOrderByConstraint extends QueryConstraint {
    readonly type = "orderBy";
}

// @public
export class QuerySnapshot<AppModelType = DocumentData, DbModelType extends DocumentData = DocumentData> {
    docChanges(options?: SnapshotListenOptions): Array<DocumentChange<AppModelType, DbModelType>>;
    get docs(): Array<QueryDocumentSnapshot<AppModelType, DbModelType>>;
    get empty(): boolean;
    forEach(callback: (result: QueryDocumentSnapshot<AppModelType, DbModelType>) => void, thisArg?: unknown): void;
    readonly metadata: SnapshotMetadata;
    readonly query: Query<AppModelType, DbModelType>;
    get size(): number;
}

// @public
export class QueryStartAtConstraint extends QueryConstraint {
    readonly type: 'startAt' | 'startAfter';
}

// @public
export function refEqual<AppModelType, DbModelType extends DocumentData>(left: DocumentReference<AppModelType, DbModelType> | CollectionReference<AppModelType, DbModelType>, right: DocumentReference<AppModelType, DbModelType> | CollectionReference<AppModelType, DbModelType>): boolean;

// @beta (undocumented)
export class RegexContains extends FirestoreFunction implements FilterCondition {
    constructor(expr: Expr, pattern: Expr);
    // (undocumented)
    filterable: true;
    }

// @beta
export function regexContains(left: string, pattern: string): RegexContains;

// @beta
export function regexContains(left: string, pattern: Expr): RegexContains;

// @beta
export function regexContains(left: Expr, pattern: string): RegexContains;

// @beta
export function regexContains(left: Expr, pattern: Expr): RegexContains;

// @beta (undocumented)
export class RegexMatch extends FirestoreFunction implements FilterCondition {
    constructor(expr: Expr, pattern: Expr);
    // (undocumented)
    filterable: true;
    }

// @beta
export function regexMatch(left: string, pattern: string): RegexMatch;

// @beta
export function regexMatch(left: string, pattern: Expr): RegexMatch;

// @beta
export function regexMatch(left: Expr, pattern: string): RegexMatch;

// @beta
export function regexMatch(left: Expr, pattern: Expr): RegexMatch;

// @beta (undocumented)
export class ReplaceAll extends FirestoreFunction {
    constructor(value: Expr, find: Expr, replace: Expr);
    }

// @beta
export function replaceAll(value: Expr, find: string, replace: string): ReplaceAll;

// @beta
export function replaceAll(value: Expr, find: Expr, replace: Expr): ReplaceAll;

// @beta
export function replaceAll(field: string, find: string, replace: string): ReplaceAll;

// @beta (undocumented)
export class ReplaceFirst extends FirestoreFunction {
    constructor(value: Expr, find: Expr, replace: Expr);
    }

// @beta
export function replaceFirst(value: Expr, find: string, replace: string): ReplaceFirst;

// @beta
export function replaceFirst(value: Expr, find: Expr, replace: Expr): ReplaceFirst;

// @beta
export function replaceFirst(field: string, find: string, replace: string): ReplaceFirst;

// @beta (undocumented)
export class Reverse extends FirestoreFunction {
    constructor(value: Expr);
    }

// @beta
export function reverse(expr: Expr): Reverse;

// @beta
export function reverse(field: string): Reverse;

// @public
export function runTransaction<T>(firestore: Firestore, updateFunction: (transaction: Transaction) => Promise<T>, options?: TransactionOptions): Promise<T>;

// @beta (undocumented)
export class Select implements Stage {
    constructor(projections: Map<string, Expr>);
    // (undocumented)
    name: string;
    }

// @beta
export interface Selectable extends Expr {
    // (undocumented)
    selectable: true;
}

// @public
export function serverTimestamp(): FieldValue;

// @public
export function setDoc<AppModelType, DbModelType extends DocumentData>(reference: DocumentReference<AppModelType, DbModelType>, data: WithFieldValue<AppModelType>): Promise<void>;

// @public
export function setDoc<AppModelType, DbModelType extends DocumentData>(reference: DocumentReference<AppModelType, DbModelType>, data: PartialWithFieldValue<AppModelType>, options: SetOptions): Promise<void>;

// @beta @deprecated
export function setIndexConfiguration(firestore: Firestore, configuration: IndexConfiguration): Promise<void>;

// @beta @deprecated
export function setIndexConfiguration(firestore: Firestore, json: string): Promise<void>;

// @public
export function setLogLevel(logLevel: LogLevel): void;

// @public
export type SetOptions = {
    readonly merge?: boolean;
} | {
    readonly mergeFields?: Array<string | FieldPath>;
};

// @public
export function snapshotEqual<AppModelType, DbModelType extends DocumentData>(left: DocumentSnapshot<AppModelType, DbModelType> | QuerySnapshot<AppModelType, DbModelType>, right: DocumentSnapshot<AppModelType, DbModelType> | QuerySnapshot<AppModelType, DbModelType>): boolean;

// @public
export interface SnapshotListenOptions {
    readonly includeMetadataChanges?: boolean;
    readonly source?: ListenSource;
}

// @public
export class SnapshotMetadata {
    readonly fromCache: boolean;
    readonly hasPendingWrites: boolean;
    isEqual(other: SnapshotMetadata): boolean;
}

// @public
export interface SnapshotOptions {
    readonly serverTimestamps?: 'estimate' | 'previous' | 'none';
}

// @beta (undocumented)
export class Sort implements Stage {
    constructor(orders: Ordering[]);
    // (undocumented)
    name: string;
    }

// @beta (undocumented)
export interface Stage {
    // (undocumented)
    name: string;
}

// @public
export function startAfter<AppModelType, DbModelType extends DocumentData>(snapshot: DocumentSnapshot<AppModelType, DbModelType>): QueryStartAtConstraint;

// @public
export function startAfter(...fieldValues: unknown[]): QueryStartAtConstraint;

// @public
export function startAt<AppModelType, DbModelType extends DocumentData>(snapshot: DocumentSnapshot<AppModelType, DbModelType>): QueryStartAtConstraint;

// @public
export function startAt(...fieldValues: unknown[]): QueryStartAtConstraint;

// @beta (undocumented)
export class StartsWith extends FirestoreFunction implements FilterCondition {
    constructor(expr: Expr, prefix: Expr);
    // (undocumented)
    filterable: true;
    }

// @beta
export function startsWith(expr: string, prefix: string): StartsWith;

// @beta
export function startsWith(expr: string, prefix: Expr): StartsWith;

// @beta
export function startsWith(expr: Expr, prefix: string): StartsWith;

// @beta
export function startsWith(expr: Expr, prefix: Expr): StartsWith;

// @beta (undocumented)
export class StrConcat extends FirestoreFunction {
    constructor(first: Expr, rest: Expr[]);
    }

// @beta
export function strConcat(first: string, ...elements: Array<Expr | string>): StrConcat;

// @beta
export function strConcat(first: Expr, ...elements: Array<Expr | string>): StrConcat;

// @beta (undocumented)
export class StrContains extends FirestoreFunction implements FilterCondition {
    constructor(expr: Expr, substring: Expr);
    // (undocumented)
    filterable: true;
    }

// @beta
export function strContains(left: string, substring: string): StrContains;

// @beta
export function strContains(left: string, substring: Expr): StrContains;

// @beta
export function strContains(left: Expr, substring: string): StrContains;

// @beta
export function strContains(left: Expr, substring: Expr): StrContains;

// @beta (undocumented)
export class Subtract extends FirestoreFunction {
    constructor(left: Expr, right: Expr);
    }

// @beta
export function subtract(left: Expr, right: Expr): Subtract;

// @beta
export function subtract(left: Expr, right: any): Subtract;

// @beta
export function subtract(left: string, right: Expr): Subtract;

// @beta
export function subtract(left: string, right: any): Subtract;

// @beta (undocumented)
export class Sum extends FirestoreFunction implements Accumulator {
    constructor(value: Expr, distinct: boolean);
    // (undocumented)
    accumulator: true;
    }

// @public
export function sum(field: string | FieldPath): AggregateField<number>;

// @beta
export function sumFunction(value: Expr): Sum;

// @beta
export function sumFunction(value: string): Sum;

// @public
export type TaskState = 'Error' | 'Running' | 'Success';

// @public
export function terminate(firestore: Firestore): Promise<void>;

// @public
export class Timestamp {
    constructor(
    seconds: number,
    nanoseconds: number);
    static fromDate(date: Date): Timestamp;
    static fromMillis(milliseconds: number): Timestamp;
    isEqual(other: Timestamp): boolean;
    readonly nanoseconds: number;
    static now(): Timestamp;
    readonly seconds: number;
    toDate(): Date;
    toJSON(): {
        seconds: number;
        nanoseconds: number;
    };
    toMillis(): number;
    toString(): string;
    valueOf(): string;
}

// @beta (undocumented)
export class TimestampAdd extends FirestoreFunction {
    constructor(timestamp: Expr, unit: Expr, amount: Expr);
    }

// @beta
export function timestampAdd(timestamp: Expr, unit: Expr, amount: Expr): TimestampAdd;

// @beta
export function timestampAdd(timestamp: Expr, unit: 'microsecond' | 'millisecond' | 'second' | 'minute' | 'hour' | 'day', amount: number): TimestampAdd;

// @beta
export function timestampAdd(field: string, unit: 'microsecond' | 'millisecond' | 'second' | 'minute' | 'hour' | 'day', amount: number): TimestampAdd;

// @beta (undocumented)
export class TimestampSub extends FirestoreFunction {
    constructor(timestamp: Expr, unit: Expr, amount: Expr);
    }

// @beta
export function timestampSub(timestamp: Expr, unit: Expr, amount: Expr): TimestampSub;

// @beta
export function timestampSub(timestamp: Expr, unit: 'microsecond' | 'millisecond' | 'second' | 'minute' | 'hour' | 'day', amount: number): TimestampSub;

// @beta
export function timestampSub(field: string, unit: 'microsecond' | 'millisecond' | 'second' | 'minute' | 'hour' | 'day', amount: number): TimestampSub;

// @beta (undocumented)
export class TimestampToUnixMicros extends FirestoreFunction {
    constructor(input: Expr);
    }

// @beta
export function timestampToUnixMicros(expr: Expr): TimestampToUnixMicros;

// @beta
export function timestampToUnixMicros(field: string): TimestampToUnixMicros;

// @beta (undocumented)
export class TimestampToUnixMillis extends FirestoreFunction {
    constructor(input: Expr);
    }

// @beta
export function timestampToUnixMillis(expr: Expr): TimestampToUnixMillis;

// @beta
export function timestampToUnixMillis(field: string): TimestampToUnixMillis;

// @beta (undocumented)
export class TimestampToUnixSeconds extends FirestoreFunction {
    constructor(input: Expr);
    }

// @beta
export function timestampToUnixSeconds(expr: Expr): TimestampToUnixSeconds;

// @beta
export function timestampToUnixSeconds(field: string): TimestampToUnixSeconds;

// @beta (undocumented)
export class ToLower extends FirestoreFunction {
    constructor(expr: Expr);
    }

// @beta
export function toLower(expr: string): ToLower;

// @beta
export function toLower(expr: Expr): ToLower;

// @beta (undocumented)
export class ToUpper extends FirestoreFunction {
    constructor(expr: Expr);
    }

// @beta
export function toUpper(expr: string): ToUpper;

// @beta
export function toUpper(expr: Expr): ToUpper;

// @public
export class Transaction {
    delete<AppModelType, DbModelType extends DocumentData>(documentRef: DocumentReference<AppModelType, DbModelType>): this;
    get<AppModelType, DbModelType extends DocumentData>(documentRef: DocumentReference<AppModelType, DbModelType>): Promise<DocumentSnapshot<AppModelType, DbModelType>>;
    set<AppModelType, DbModelType extends DocumentData>(documentRef: DocumentReference<AppModelType, DbModelType>, data: WithFieldValue<AppModelType>): this;
    set<AppModelType, DbModelType extends DocumentData>(documentRef: DocumentReference<AppModelType, DbModelType>, data: PartialWithFieldValue<AppModelType>, options: SetOptions): this;
    update<AppModelType, DbModelType extends DocumentData>(documentRef: DocumentReference<AppModelType, DbModelType>, data: UpdateData<DbModelType>): this;
    update<AppModelType, DbModelType extends DocumentData>(documentRef: DocumentReference<AppModelType, DbModelType>, field: string | FieldPath, value: unknown, ...moreFieldsAndValues: unknown[]): this;
}

// @public
export interface TransactionOptions {
    readonly maxAttempts?: number;
}

// @beta (undocumented)
export class Trim extends FirestoreFunction {
    constructor(expr: Expr);
    }

// @beta
export function trim(expr: string): Trim;

// @beta
export function trim(expr: Expr): Trim;

// @public
export type UnionToIntersection<U> = (U extends unknown ? (k: U) => void : never) extends (k: infer I) => void ? I : never;

// @beta (undocumented)
export class UnixMicrosToTimestamp extends FirestoreFunction {
    constructor(input: Expr);
    }

// @beta
export function unixMicrosToTimestamp(expr: Expr): UnixMicrosToTimestamp;

// @beta
export function unixMicrosToTimestamp(field: string): UnixMicrosToTimestamp;

// @beta (undocumented)
export class UnixMillisToTimestamp extends FirestoreFunction {
    constructor(input: Expr);
    }

// @beta
export function unixMillisToTimestamp(expr: Expr): UnixMillisToTimestamp;

// @beta
export function unixMillisToTimestamp(field: string): UnixMillisToTimestamp;

// @beta (undocumented)
export class UnixSecondsToTimestamp extends FirestoreFunction {
    constructor(input: Expr);
    }

// @beta
export function unixSecondsToTimestamp(expr: Expr): UnixSecondsToTimestamp;

// @beta
export function unixSecondsToTimestamp(field: string): UnixSecondsToTimestamp;

// @public
export interface Unsubscribe {
    (): void;
}

// @public
export type UpdateData<T> = T extends Primitive ? T : T extends {} ? {
    [K in keyof T]?: UpdateData<T[K]> | FieldValue;
} & NestedUpdateFields<T> : Partial<T>;

// @public
export function updateDoc<AppModelType, DbModelType extends DocumentData>(reference: DocumentReference<AppModelType, DbModelType>, data: UpdateData<DbModelType>): Promise<void>;

// @public
export function updateDoc<AppModelType, DbModelType extends DocumentData>(reference: DocumentReference<AppModelType, DbModelType>, field: string | FieldPath, value: unknown, ...moreFieldsAndValues: unknown[]): Promise<void>;

// @public
export function vector(values?: number[]): VectorValue;

// @beta (undocumented)
export class VectorLength extends FirestoreFunction {
    constructor(value: Expr);
    }

// @beta
export function vectorLength(expr: Expr): VectorLength;

// @beta
export function vectorLength(field: string): VectorLength;

// @public
export class VectorValue {
    /* Excluded from this release type: __constructor */
    isEqual(other: VectorValue): boolean;
    toArray(): number[];
}

// @public
export function waitForPendingWrites(firestore: Firestore): Promise<void>;

// @beta (undocumented)
export class Where implements Stage {
    constructor(condition: FilterCondition);
    // (undocumented)
    name: string;
}

// @public
export function where(fieldPath: string | FieldPath, opStr: WhereFilterOp, value: unknown): QueryFieldFilterConstraint;

// @public
export type WhereFilterOp = '<' | '<=' | '==' | '!=' | '>=' | '>' | 'array-contains' | 'in' | 'array-contains-any' | 'not-in';

// @public
export type WithFieldValue<T> = T | (T extends Primitive ? T : T extends {} ? {
    [K in keyof T]: WithFieldValue<T[K]> | FieldValue;
} : never);

// @public
export class WriteBatch {
    commit(): Promise<void>;
    delete<AppModelType, DbModelType extends DocumentData>(documentRef: DocumentReference<AppModelType, DbModelType>): WriteBatch;
    set<AppModelType, DbModelType extends DocumentData>(documentRef: DocumentReference<AppModelType, DbModelType>, data: WithFieldValue<AppModelType>): WriteBatch;
    set<AppModelType, DbModelType extends DocumentData>(documentRef: DocumentReference<AppModelType, DbModelType>, data: PartialWithFieldValue<AppModelType>, options: SetOptions): WriteBatch;
    update<AppModelType, DbModelType extends DocumentData>(documentRef: DocumentReference<AppModelType, DbModelType>, data: UpdateData<DbModelType>): WriteBatch;
    update<AppModelType, DbModelType extends DocumentData>(documentRef: DocumentReference<AppModelType, DbModelType>, field: string | FieldPath, value: unknown, ...moreFieldsAndValues: unknown[]): WriteBatch;
}

// @public
export function writeBatch(firestore: Firestore): WriteBatch;

// @beta (undocumented)
export class Xor extends FirestoreFunction implements FilterCondition {
    constructor(conditions: (FilterCondition)[]);
    // (undocumented)
    filterable: true;
}

// @beta
export function xor(left: FilterCondition, ...right: (FilterCondition)[]): Xor;


// Warnings were encountered during analysis:
//
// /Users/markduckworth/projects/firebase-js-sdk/packages/firestore/dist/all_packages.d.ts:5962:26 - (ae-incompatible-release-tags) The symbol "accumulators" is marked as @public, but its signature references "AccumulatorTarget" which is marked as @beta
// /Users/markduckworth/projects/firebase-js-sdk/packages/firestore/dist/all_packages.d.ts:5962:61 - (ae-incompatible-release-tags) The symbol "groups" is marked as @public, but its signature references "Selectable" which is marked as @beta
// /Users/markduckworth/projects/firebase-js-sdk/packages/firestore/dist/all_packages.d.ts:5989:21 - (ae-incompatible-release-tags) The symbol "orderings" is marked as @public, but its signature references "Ordering" which is marked as @beta

```
